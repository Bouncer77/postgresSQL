# Введение

## Терминология



Structured Query Language (SQL)

Запросы пишутся на ЯМД (DML) (Язык Манипулирования Данными) (Data Manipulation Language)

Схема - раздел базы данных, в котором и создаются таблицы и другие объекты (По умолчанию используется схема public) - пространство имён для таблиц

Индекс — это специальная структура данных, позволяющая решать задачу ускорения доступа к строкам в таблице, а также задачу предотвращения дублирования значений ключевых атрибутов в различных строках таблицы. Для реализации первичного ключа (PRIMARY KEY) всегда автоматически создается индекс.

# Глава 1

* плоские файлы (flat files)
	данные хранились в виде записей, разделенных на поля фиксированной длины

> модель данных
	характеризует способ организации данных и основные методы
	доступа к ним

иерархическая и сетевая модели данных
	подход к работе с базами данных назывался навигационным — программист указывал программе конкретный алгоритм поиска записей

реляционная модель данных
	способность поддерживать связи между элементами данных

декларативные языки для общения с БД
	для получения результата достаточно лишь указать, что нужно получить, но не требуется предписывать
	способ получения результата, т. е. как его получить.

Система баз данных 
	— это компьютеризированная система, предназначенная для
	хранения, переработки и выдачи информации по запросу пользователей. Такая система включает в себя программное и аппаратное обеспечение, сами данные, а также
	пользователей

СУБД (DBMS) (система управления базами данных)
(Database Management System)

Пользователи СУБД
1. прикладные программисты
2. конечные пользователи
3. администраторы базы данных

процессор языка запросов
	Часть СУБД, позволяющая пользователю вводить команды высокого уровня SQL

Система баз данных
1. сервер (СУБД)
2. набор клиентов (или внешних интерфейсов)
	различные приложения, написанные прикладными программистами, или встроенные приложения, поставляемые вместе с СУБД

Словарь данных 
	часть базы данных, которая описывает сами данные, хранящиеся в ней (Метаданные)

Формальная теория реляционных баз данных - Теория

 Практика | Теория   | До существования РСУБД
 ---------|----------|-------------------------
Таблица   | отношениями (relations)        | файлов
Строка    | кортежами (tuples)         | записей
Столбец (колонка)  | атрибут          | поля

Отношение — это математический термин

Отношение имеет заголовок, который состоит из атрибутов, и тело, состоящее из кортежей

Количество атрибутов называется степенью отношения, а количество кортежей — кардинальным числом.

реляционной теории
1. теория множеств
2. исчисление предикатов
	раздел математической логики

## Ключи 

составным Потенциальный ключ

	комбинация атрибутов таблицы, позволяющая уникальным образом идентифицировать строки в ней

	потенциальный ключ должен быть неизбыточным, т. е.
	никакое подмножество атрибутов, входящих в него, не должно обладать 	свойством
	уникальности


первичного ключа
альтернативными ключами

## внешним ключом

Термин                                   | Описание
-----------------------------------------|------------
ссылающейся таблицей (referencing table) | Таблица, содержащая внешний ключ
ссылочной (referenced) (целевой)                   | Таблица, содержащая первичный ключ, который используется в других таблицах как внешний

проблема ссылочной целостности

	Проблема обеспечения того, чтобы база данных не содержала неверных значений внешних ключей,
	известна как проблема ссылочной целостности

	Ограничение, согласно которому
	значения внешних ключей должны соответствовать значениям потенциальных ключей, называется ограничением ссылочной целостности (ссылочным ограничением)

Обеспечением выполнения ограничений ссылочной целостности занимается СУБД

каскадным удалением (обновлением)
	При проектировании баз данных часто предусматривается, что при удалении строки из ссылочной таблицы соответствующие строки из ссылающейся таблицы
	должны быть также удалены, а при изменении значения столбца, на который ссылается внешний ключ, должны быть изменены значения внешнего ключа в ссылающейся таблице.

Транзакция
	
	набор
	операций над базой данных, рассматриваемых как единая и неделимая единица работы, выполняемая полностью или не выполняемая вовсе, если произошел какойто сбой в процессе выполнения транзакции.

	транзакции являются
	средством обеспечения согласованности данных

## Язык SQL

	непроцедурный язык, который является стандартным средством работы с данными во всех реляционных СУБД

### Группа операторов в SQL

1. Язык Определения Данных (ЯОД) (Data Definition Language — DDL)
	CREATE, INSERT, UPDATE
2. Язык Манипулирования Данными (ЯМД) (Data Manipulation Language — DML)
3. управляющих привилегиями доступа к объектам базы данных (Data Control Language — DCL)

### БД для курса

описание базы данных «Авиаперевозки» 

 https://postgrespro.ru/education/demodb и https://postgrespro.ru/docs/postgrespro/
current/demodb-bookings.html

### Установка

дистрибутива СУБД Postgres Pro и содержит не только
все функции и модули, входящие в состав стандартного дистрибутива, но и дополнительные разработки, выполненные в компании Postgres Professional. -  https://postgrespro.ru/products/postgrespro/download/latest

оригинальным дистрибутивом PostgreSQL -  https://www.postgresql.org/download/

учетная запись пользователя СУБД - postgres

Запуск сервера баз данных
 https://postgrespro.ru/docs/postgresql/current/server-start.html
 При установке СУБД в среде Windows создается служба (service) для
автоматического запуска сервера PostgreSQL при загрузке операционной системы

Выключение сервера
https://postgrespro.ru/docs/postgresql/9.6/server-shutdown.html

## Глава 3 Основные операции с таблицами

Ключи идентифицируют экземпляр строки (кортеж) в таблице (отношении)

Естественные ключи - например код самолета - обладают смысловой нагрузкой, в реальной предметной области существуют такие понятия

Суррогатные ключи - искуственные ключи - не обладают смысловой нагрузкой

## Кодстайл

утилита pg_dump (входящая в комплект поставки PostgreSQL), которая
предназначена для создания резервной копии базы данных

Прописывает ключевые слова SQL прописными (заглавными, буквами в верхнем регистре) буквами, кроме типов данных (integer, char, text и т. д.), пользовательские имена идентификаторов пишутся в строчными буквами (в нижнем регистре).

Завершение

## Глава 4 - Типы данных

* целочисленные типы - smallint, integer, bigint - их псевдонимы: int2, int4 и int8
* числа фиксированной точности - numeric и decimal
	numeric(точность, масштаб)
	масштаб (scale) и точность (precision)
	Масштаб показывает число значащих цифр, стоящих справа от десятичной точки (запятой).	
	Точность указывает общее число цифр как до десятичной точки, так и после нее.
	12.3456 точность составляет 6 цифр, а масштаб — 4 цифры.
	Числа типа numeric могут хранить очень большое количество цифр: 131 072 цифры — до десятичной точки (запятой), 16 383 — после точки.

	специальное значение NaN, которое означает «не число» (not a number) В документации утверждается, что значение NaN
	считается равным другому значению NaN, а также что значение NaN считается
	большим любого другого «нормального» значения, т. е. не-NaN. Проверьте эти ´
	утверждения с помощью SQL-команды SELECT
	SELECT 'NaN'::numeric > 10000;


	'+' когда требуется гарантировать точность вычислений
	'-' замедления вычислений по сравнению с целочисленными типами и типами с плавающей точкой
	'-' для хранения числа затрачивается больше памяти, чем в случае целых чисел

* типы данных с плавающей точкой - real и double precision, float

	реализацию стандарта IEEE «Standard 754 for Binary Floating-Point Arithmetic»
	
	float(p)
	значение лежит в диапазоне от 1 до 24, то float равносильно real
	от 25 до 53 - double precision

	Тип данных real: от 1E−37 до 1E+37 с точностью не меньше 6 десятичных цифр
	Тип double precision имеет диапазон значений примерно от 1E−307 до 1E+308 с точностью не меньше 15 десятичных цифр
	пециальные значения Infinity (бесконечность), −Infinity (отрицательная бесконечность) и NaN (не число)

	При работе с числами типов real и double precision нужно помнить, что
	сравнение двух чисел с плавающей точкой на предмет равенства их значений
	может привести к неожиданным результатам.

	SELECT 'Inf'::double precision > 1E+308; -- t

	Типы данных real и double precision поддерживают специальное значение
	NaN, которое означает «не число» (not a number).

	SELECT 0.0 * 'Inf'::real; - NaN

* последовательные типы - bigserial и smallserial, serial

	Тип serial удобен в тех случаях, когда требуется в какой-либо столбец вставлять уникальные целые значения, например, значения суррогатного первичного ключа.

```sql
--Синтаксис для создания столбца типа serial таков:
CREATE TABLE имя-таблицы ( имя-столбца serial );

--Эта команда эквивалентна следующей группе команд:
CREATE SEQUENCE имя-таблицы_имя-столбца_seq;
CREATE TABLE имя-таблицы
(
имя-столбца integer NOT NULL
DEFAULT nextval( 'имя-таблицы_имя-столбца_seq' )
);
ALTER SEQUENCE имя-таблицы_имя-столбца_seq
OWNED BY имя-таблицы.имя-столбца;
````

* Символьные (строковые) типы - character varying(n) и character(n), text - псевдонимы: varchar(n) и char(n) 

	n - максимальное число символов в строке, которую можно сохранить в столбце такого типа

	Если сохраняемая строка символов будет короче, чем указано в определении типа, то значение типа character будет дополнено пробелами до требуемой длины, а значение типа character varying будет сохранено так, как есть.

	Константы символьных типов в SQL-командах заключаются в одинарные кавычки

	Экранирование одинарной кавычки делается дублированием этой кавычки 

	SELECT 'PGDAY''17'; <=> SELECT $$PGDAY'17$$; <=> SELECT E'PGDAY\'17'; -- PGDAY'17

	При использовании символов «$» в качестве ограничителей уже не нужно удваивать никакие символы, содержащиеся в самой константе: ни одинарные кавычки, ни символы обратной косой черты.

	Строковые константы со спецпоследовательностями в стиле C

	SELECT E'PGDAY\n17';

	При использовании C-стиля необходимо удваивать обратную косую черту, если требуется поместить ее в константу буквально. 

* Дата и время - дата: date; время суток:  time и time with time zone / интегральный тип —
временная отметка:  timestamp with time zone (псевдоним: timestamptz) , либо без учета часового пояса — timestamp / отрезок времени - interval

	Даты обрабатываются в соответствии с григорианским календарем

	Рекомендуемый стандартом ISO 8601 формат ввода дат таков: «yyyy-mm-dd»,
	где символы «y» - обозначают цифру года
	«m» - цифра месяца
	«d» - цифра дня

	SELECT '2016-09-12'::date; <=> SELECT 'Sep 12, 2016'::date;

	:: - приведения типа + проверка значения на соответствие формату целевого типа и множеству его допустимых значений

	SELECT current_date;  -- получения значения текущей даты

	Вывести дату в другом формате:
	SELECT to_char( current_date, 'dd-mm-yyyy' );

	time - хранит время суток

	time with time zone - хранит время суток + часовой пояс
 	не рекомендован, так как не хранит дату, а следовательно смещение (offset) , соответствующее конкретному часовому поясу, может зависеть от даты перехода на летнее время и обратно

	
	Время можно вводить не только в 24-часовом формате, но и в 12-часовом, при этом нужно использовать дополнительные суффиксы am и pm. Например:
 	SELECT '21:15'::time; SELECT '21:15:26'::time;
 	SELECT '10:15:16 am'::time; SELECT '10:15:16 pm'::time;

 	SELECT timestamp with time zone '2016-09-21 22:25:35'; -- timestamptz : 2016-09-21 22:25:35+03
 	локальному часовому поясу, который установлен в конфигурационном файле сервера PostgreSQL
 	SELECT timestamp '2016-09-21 22:25:35'; -- timestampt : 2016-09-21 22:25:35

 	SELECT current_timestamp; <=> SELECT now(); -- получение значения текущей временной отметки

 	Оба типа — timestamp и timestamptz — занимают один и тот же объем 8 байтов, но значения типа timestamptz хранятся, будучи приведенными к нулевому часовому поясу (UTC), а перед выводом приводятся к часовому поясу пользователя

 	Например, в расписании авиарейсов указывается местное время как для аэропорта отправления, так и для аэропорта прибытия. Поэтому в таком случае нужно использовать тип timestamp, чтобы это время не приводилось к текущему часовому поясу пользователя, где бы он ни находился

 	quantity unit [quantity unit ...] direction
 	, где unit - единицу измерения (microsecond, millisecond, second, minute, hour, day, week, month, year, decade, century, millennium)
 	quantity - количество таких единиц (может принимать значение ago (т. е. «тому назад») либо быть пустым)

 	SELECT '1 year 2 months ago'::interval; -- -1 years -2 mons

 	стандартом ISO 8601:
	P [ years-months-days ] [ T hours:minutes:seconds ]
	Здесь строка должна начинаться с символа «P», а символ «T» разделяет дату и время (все выражение пишется без пробелов).
	SELECT 'P0001-02-03T04:05:06'::interval; -- 1 year 2 mons 3 days 04:05:06

	Операции
	SELECT ('2016-09-16'::timestamp - '2016-09-01'::timestamp)::interval; -- 15 days

	Функции
	current_date - текущей даты
	current_time - текущего времени
	current_timestamp - текущей временной отметки
	Их особенностью является то, что при их вызове круглые скобки не используются

	date_trunc() - Значения временных отметок можно усекать с той или иной точностью
	SELECT ( date_trunc( 'hour', current_timestamp ) ); -- 2016-09-27 22:00:00+03

	Из значений временных отметок можно извлекать отдельные поля
	SELECT extract( 'mon' FROM timestamp '1999-11-27 12:34:56.123459' ); -- извлекает номер месяца 11
	Напомним, что выражение timestamp '1999-11-27 12:34:56.123459' не означает операцию приведения типа. Оно присваивает тип данных timestamp литеральной константе.

* Логический тип - boolean
	
	тип boolean реализует трехзначную логику:
	* истина - TRUE, 't', 'true', 'y', 'yes', 'on', '1'.
	* ложь - FALSE, 'f', 'false', 'n', 'no', 'off', '0'
	* NULL - неопределенное состояние

* Массивы
	
	Для указания на то, что это массив, нужно добавить квадратные скобки к наименованию типа данных

```sql
-- графики работы пилотов авиакомпании
CREATE TABLE pilots
(
pilot_name text,
schedule integer[]
-- <=>
schedule integer ARRAY
);

INSERT INTO pilots
VALUES ( 'Ivan', '{ 1, 3, 5, 6, 7 }'::integer[] ),
( 'Petr', '{ 1, 2, 5, 7 }'::integer[] ),
( 'Pavel', '{ 2, 5 }'::integer[] ),
( 'Boris', '{ 3, 5, 6 }'::integer[] );
-- INSERT 0 4

-- добавить один день в расписание пилота Бориса
UPDATE pilots
SET schedule = schedule || 7 -- в конец с помощью операции конкатенации
 SET schedule = array_append( schedule, 7 ) -- в конец с помощью функции array_append
 SET schedule = array_prepend( 1, schedule ) -- в начало с помощью функции array_ prepend
 SET schedule = array_remove( schedule, 5 ) -- (второй параметр функции указывает значение элемента массива, а не индекс)

-- По умолчанию нумерация индексов начинается с единицы, а не с нуля.
 SET schedule[ 1 ] = 2, schedule[ 2 ] = 3 
 -- <=>
 SET schedule[ 1:2 ] = ARRAY[ 2, 3 ] -- используя срез (slice) массива
 -- 1:2 означает индексы первого и последнего элементов диапазона массива

WHERE pilot_name = 'Boris';
-- UPDATE 1

-- Список пилотов летающих по средам
SELECT * FROM pilots
WHERE array_position( schedule, 3 ) IS NOT NULL;
-- возвращает индекс первого вхождения элемента с указанным значением в массив. Если же такого элемента нет, она возвратит NULL
-- array_position( schedule, 3 ) -- позиция 3 - означает среда

-- Список пилотов летающих по понедельникам и воскресеньям
SELECT * FROM pilots
WHERE schedule @> '{ 1, 7 }'::integer[];
-- Оператор @> означает проверку того факта, что в левом массиве содержатся все элементы правого массива.

-- кто летает по вторникам и/или по пятницам?
SELECT * FROM pilots
WHERE schedule && ARRAY[ 2, 5 ]; -- '{2, 5}'::integer[]
 WHERE NOT ( schedule && ARRAY[ 2, 5 ] ); -- кто НЕ летает по вторникам и/или по пятницам?
-- && проверяет наличие общих элементов у массивов, т. е. пересекаются ли их множества значений

-- Развернуть массив в виде таблицы
SELECT unnest( schedule ) AS days_of_week
FROM pilots
WHERE pilot_name = 'Ivan';
```

* JSON - json и jsonb

	JSON (JavaScript Object Notation)





## Последовательности

генераторы уникальных целых чисел

Специальная функция | Значение
--------------------|------------------------
nextval ('имя-последовательности')| получить очередное число из последовательности, имя которой указано в качестве параметра функции

