# Основы SQL
<!-- autolink="true" -->
<!-- MarkdownTOC  -->

- SELECT
- Aliases
- Конкатенация строк
- Арифметические операции
- Where
  - Логические операторы в порядке выполнения условий \(по приоритету\) в предложение WHERE
- Операции сравнения
- BETWEEN
- IN
  - оператор вхождения в объект @> \(jsonb\)
  - jsquery
- 'хобби.*.группа=Постгрессоры'::jsquery;
  - Postgres Professional
- Интеграция с внешними системами
- Шардирование и секционирование
  - Что почитать
  - Версии СУБД

<!-- /MarkdownTOC -->

## SELECT

```sql
SELECT 'столбцы или * для выбора всех столбцов; обязательно'

FROM 'таблица; обязательно'

WHERE 'условие/фильтрация, например, city = 'Moscow'; необязательно'

GROUP BY 'столбец, по которому хотим сгруппировать данные; необязательно'

HAVING 'условие/фильтрация на уровне сгруппированных данных; необязательно'

ORDER BY 'столбец, по которому хотим отсортировать вывод; необязательно';
-- DESC (это сокращение от слова descendant — убывающий порядок)
```
 
```sql
SELECT список_полей
FROM список_таблиц
WHERE ограничения_на_список_строк
GROUP BY условия_группировки
HAVING ограничения_на_строки_после_группировки
ORDER BY порядок_сортировки
LIMIT ограничение_количества_записей;
```

## Aliases

Псевдонимы


```sql
SELECT 'Бим' AS dog_name, 'Бим' AS DOG_NAME, 'Бим' AS Dog_Name;
```
Псевдонимы без кавычек воспринимаются системой без учёта регистра. Таким образом dog_name, DOG_NAME, Dog_Name являются идентичными. (результат будет в нижнем регистре)

Если заключить псевдоним в двойные кавычки, то он становится регистрочувствительным и может состоять из произвольной последовательности символов, например "имя собаки", "1", "dogName".

## Конкатенация строк

Для выполнения конкатенации строк необходимо воспользоваться оператором ||


```sql
SELECT 'текущее время: ' || now() as time;
-- или
SELECT concat('текущее время: ', now()) as time;
```


## Арифметические операции

* + - сложение;
* - - вычитание;
* * - умножение;
* / - деление;
* % - остаток от деления;
* ^ - возведение в степень;
* ! - факториал;
* abs - модуль числа;
* sqrt - квадратный корень.

```sql
SELECT 2+3 AS plus,
       2-3 AS minus,
       2*3 AS multiply,
       2/3 AS division,
       5%3 AS remainder_of_division,
       2^3 AS degree,
       3! AS factorial,
       abs(-2),
       sqrt(9);
```

## Where

```sql
SELECT список_полей
FROM список_таблиц
WHERE ограничения_на_список_строк;
```

### Логические операторы в порядке выполнения условий (по приоритету) в предложение WHERE

1. NOT - отрицание
2. AND - логическое И
3. OR - логическое ИЛИ;

```sql
SELECT *
  FROM product_price
 WHERE store_id = 300
    OR store_id = 302
   AND price > 20000;
```
AND более приоритетаная операция, поэтому сначало выполнилось условие store_id = 302 AND price > 20000, а затем срабатывает условие OR

```sql
SELECT *
  FROM product_price
 WHERE (store_id = 300 OR store_id = 302) AND price > 20000;
```

## Операции сравнения 

* < - меньше;
* > - больше;
* <= - меньше или равно;
* >= - больше или равно;
* = - равно;
* != или <> - не равно.

## BETWEEN

```sql
SELECT *
  FROM product_price
 WHERE 30000 <= price
   AND price <= 60000;
-- или
SELECT *
  FROM product_price
 WHERE price BETWEEN 30000 AND 60000;
```

BETWEEN включает границы в интервал.
NOT BETWEEN выполняет противоположное сравнение. Так запрос

```sql
SELECT *
  FROM product_price
 WHERE price NOT BETWEEN 30000 AND 60000

SELECT *
  FROM product_price
 WHERE price < 30000
    OR price > 60000;
```

## IN 

Для проверки совпадения хотя бы с одним значением в SQL применяется конструкция IN.

```sql
SELECT *
  FROM store
 WHERE store_id IN (100, 300, 500);
```

NOT IN (значение1, значение2, ... ) выполняет противоположное сравнение. Так запрос

```sql
SELECT *
  FROM store
 WHERE store_id NOT IN (100, 300, 500)
```

Вернет имена магазинов (store), кроме тех у которых идентификатор магазина (store_id) равен 100, 300, 500.


```

### Обработка NULL значений

Одно null значение не равно другому null значению (выражение null = null вернет false).
Одно null значение не не равно другому null значению (выражение null != null вернет false).

Проверка на NULL 

```sql
SELECT *
  FROM store
 WHERE site_url IS NULL
 -- или IS NOT NULL
 ```
### ORDER BY - Сортировка

#### Сортировка по одному полю

отсортировать в обратном порядке - DESC (по умолчанию ASC - по возрастанию)

```sql
SELECT store_id, name
FROM store
ORDER BY name DESC -- DESC NULLS LAST, чтобы неопределенные значения попали не в начало, а в конец выборки.
```
#### Сортировка по нескольким полям

```sql
SELECT employee_id,
       rank_id,
       last_name
  FROM employee
 ORDER BY rank_id, last_name
```



### LIMIT - Ограничение количества строк

Конструкция LIMIT позволяет получить только часть строк от результата запроса.

Применяя LIMIT, важно использовать также предложение ORDER BY, чтобы строки результата выдавались в определённом порядке. Иначе будут возвращаться непредсказуемые подмножества строк. Вы можете запросить строки с десятой по двадцатую, но какой порядок вы имеете в виду? Порядок будет неизвестен, если не добавить ORDER BY.

написать OFFSET и сколько строк пропустить.

```sql
SELECT store_id, name
  FROM store
 ORDER BY name
 LIMIT 3
OFFSET 3
```

### Псевдоним для таблиц

В условиях соединения ON имя таблицы обычно не пишут, т.к. читать длинные портянки кода весьма утомительно. Подобно псевдонимам столбцов в списке выборки SELECT можно задать псевдонимы таблицам. Для этого после названия таблицы через пробел нужно написать псевдоним таблицы. После того, как таблице назначен псевдоним, обращаться к ней по названию уже нельзя - только по псевдониму.

Алиасы таблиц также удобно использовать в списке выборки SELECT. 

```sql
SELECT c.city_id,
       c.name,
       t.time_offset
  FROM city c
  JOIN timezone t
    ON t.timezone_id = c.timezone_id
```

# Пользователь 

Но postgres обладает
правами суперпользователя, поэтому приложению не следует использовать его для подключения к базе данных.
Лучше создать нового пользователя и сделать его владельцем отдельной базы данных — тогда его права будут ограничены этой базой.

[Документация Роли и Права доступа](https://postgrespro.ru/docs/postgrespro/12/user-manag)

```sql
CREATE USER app PASSWORD 'p@ssw0rd';
CREATE DATABASE appdb OWNER app;
-- ALTER ROLE postgres PASSWORD 'p@ssw0rd';
```

Чтобы подключиться к новой базе данных и работать с ней
от имени созданного пользователя, выполните:

```sql
\c appdb app localhost 5432
```

# Удаленное подключение

1. postgresql.conf — файл основных настроек
(обычно располагается в каталоге баз данных). Найдите
строку, определяющую, какие сетевые интерфейсы слушает PostgreSQL:
#listen_addresses = 'localhost'
и замените ее на:
listen_addresses = '*'
--
2. pg_hba.conf — файл с настройками аутентификации. Когда клиент подключается к серверу, в этом файле
выбирается первая сверху строка, соответствующая соединению по четырем параметрам: типу соединения, имени
базы данных, имени пользователя и IP-адресу клиента.
В той же строке написано, как пользователь должен подтвердить, что он действительно тот, за кого себя выдает.
Например, для ОС Debian и Ubuntu в этом файле, в числе
прочих, есть такая настройка (верхняя строка, начинающаяся с «решетки», считается комментарием):

# TYPE DATABASE USER ADDRESS METHOD
local all all peer

Она говорит, что локальные соединения (local) к любой
базе данных (all) под любым пользователем (all) должны
проверяться методом peer (IP-адрес для локальных соединений, конечно, не указывается).
Метод peer означает, что PostgreSQL запрашивает имя текущего пользователя у операционной системы и считает,96
vi
что ОС уже выполнила необходимую проверку (спросила
у пользователя пароль). Поэтому в Linux-подобных операционных системах пользователю обычно не приходится
вводить пароль при подключении к серверу на своем компьютере: достаточно того, что пароль был введен при входе
в систему.
А вот для Windows локальные соединения не поддерживаются, и там настройка выглядит следующим образом:
# TYPE DATABASE USER ADDRESS METHOD
host all all 127.0.0.1/32 md5

Она означает, что сетевые соединения (host) к любой базе
данных (all) под любым пользователем (all) с локального
адреса (127.0.0.1) должны проверяться методом md5. Этот
метод подразумевает ввод пароля пользователем.
Итак, для наших целей допишите в конец pg_hba.conf следующую строку, которая разрешит доступ к базе данных
appdb пользователю app с любого адреса при указании
верного пароля:

host appdb app all md5

После внесения изменений в конфигурационные файлы не
забудьте попросить сервер перечитать настройки:
postgres=# SELECT pg_reload_conf();

[Подробнее о настройках аутентификации](postgrespro.ru/doc/client-authentication.html)

## Связаться из приложения с БД

Обычно драйвер СУБД представляет собой обертку для libpq — штатной библиотеки, реализующий клиент-серверный протокол PostgreSQL

C:\> chcp 1251
Active code page: 1251
C:\> set PGCLIENTENCODING=WIN1251

$ sudo apt-get install openjdk-7-jdk
$ sudo apt-get install libpostgresql-jdbc-java

[OpenJDK](http://www.oracle.com/technetwork/java/javase/downloads)

[Драйвер JDBC](http://jdbc.postgresql.org)

```java
// Пример программы (Test.java):

import java.sql.*;

public class Test {
    public static void main(String[] args)
                  throws SQLException {
        Connection conn = DriverManager.getConnection("jdbc:postgresql://localhost:5432/appdb","app", "p@ssw0rd");
        Statement st = conn.createStatement();
        ResultSet rs = st.executeQuery("SELECT * FROM greeting");
        
        while (rs.next()) {
            System.out.println(rs.getString(1));
        }

        rs.close();
        st.close();
        conn.close();
    }
}
```
Компилируем и выполняем программу, указывая в ключе
путь к классу-драйверу JDBC (в Windows пути разделяются
не двоеточием, а точкой с запятой):102
vi
$ javac Test.java
$ java -cp .:/usr/share/java/postgresql-jdbc4.jar \
Test


### Резервное копирование

[Утилита pg_dump](https://postgrespro.ru/doc/app-pgdump)

$ pg_dump appdb > appdb.dump
$ createdb appdb2
$ psql -d appdb2 -f appdb.dump

Если требуется сделать резервную копию
кластера, включая все базы данных, пользователей и табличные пространства

`pg_dumpall`


Для больших серьезных проектов требуется продуманная
стратегия периодического резервного копирования. Для
этого лучше подойдет физическая «двоичная» копия кластера, которую создает утилита pg_basebackup:

$ pg_basebackup -D backup

Такая команда создаст резервную копию всего кластера
баз данных в каталоге backup. Чтобы восстановить систему
из созданной копии, достаточно скопировать ее в каталог
баз данных и запустить сервер.
Подробнее про все доступные средства резервного копирования и восстановления смотрите в документации:
postgrespro.ru/doc/backup.html, а также в учебном курсе
postgrespro.ru/education/courses/DBA3.

pg_probackup — инструменты для
резервного копирования и восстановления есть и у нашей компании Postgres
Professional. Он распространяется свободно и позволяет
выполнять инкрементальное резервное копирование на
уровне страниц, контролировать целостность данных, работать с большими объемами информации за счет параллелизма и сжатия, реализовывать различные стратегии резервного копирования. Полная документация доступна по
адресу postgrespro.ru/doc/app-pgprobackup

## Что дальше

Серверная часть - относится к СУБД:

1. таблицы
2. индексы
3. представления
4. триггеры
5. хранимые функции

А клиентская — все, что работает вне СУБД и подключается к СУБД


ORM-ом, который автоматически генерирует запросы к базе данных из конструкций на языке программирования, привычном разработчикам. Иногда такое решение мотивируют желанием обеспечить переносимость
приложения на любую СУБД.

язык
серверного программирования (обычно PL/pgSQL) для написания функций и триггеров. 

В pgAdmin есть встроенный отладчик PL/pgSQL-кода

### JSON и JSONB

Тип json и появившийся позже jsonb, в котором данные хранятся в экономичном
бинарном виде, и который, в отличие от json, приспособлен к созданию индексов, ускоряющих поиск иногда на
порядки.

Буква «b»
подразумевает бинарный (а не текстовый) способ хранения данных. Такие данные можно плотно упаковать и поиск
по ним работает быстрее. Последнее время jsonb используется намного чаще, чем json

Мы использовали функцию jsonb_pretty(), которая форматирует вывод типа jsonb.
Или можно воспользоваться функцией jsonb_each(), разворачивающей пары ключ-значение

### Преобразование JSON в JSONB

test=# ALTER TABLE student_details
ADD details_b jsonb;

test=# UPDATE student_details
SET details_b = to_jsonb(details);

test=# SELECT de_id, details_b
FROM student_details \gx


#### Оператор ->>

Мы можем обратиться к содержанию ключа «достоинство», используя специальный
оператор ->>:

test=# SELECT s.name, sd.details
FROM student_details sd, students s
WHERE s.s_id = sd.s_id
AND sd.details ->> 'достоинства' IS NOT NULL
\gx


### Оператор #> (json)

Проблема:

Попробуем найти,
на каких гитарах играет музыкант Витя:

```sql
SELECT sd.de_id, s.name, sd.details
FROM student_details sd, students s
WHERE s.s_id = sd.s_id
AND sd.details ->> 'гитары' IS NOT NULL
\gx
```

Запрос ничего не выдаст. Дело в том, что соответствующая
пара ключ-значение находится внутри иерархии JSON, вложена в пары более высокого уровня:

name    | Виктор
details | { "хобби":                                 +
|      { "гитарист":                        +
|           { "группа": "Постгрессоры",     +
|             "гитары":["страт","телек"]    +
|           }                                 +
|      }                                     +
| }

Оператор #> позволяет искать вхождение ключа в парах ключ-значение на один уровень ниже по иерархии JSON файла

Чтобы  добраться  до  гитар,  воспользуемся  оператором  #>
и спустимся с «хобби» вниз по иерархии:

```sql
SELECT sd.de_id, s.name,
sd.details #> '{хобби,гитарист,гитары}'
FROM student_details sd, students s
WHERE s.s_id = sd.s_id
AND sd.details #> '{хобби,гитарист,гитары}'
IS NOT NULL
\gx
```

### оператор вхождения в объект @> (jsonb)

Один из
полезнейших операторов — оператор вхождения в объект
@>. Он напоминает #> для json.

Среди имеющихся для jsonb индексов, как
правило, лучше всего подходит GIN. Для json индексы не
поддерживаются, поэтому для приложений с серьезной нагрузкой как правило лучше выбирать jsonb, а не json.

[Подробнее о JSON и JSONB](https://postgrespro.ru/doc/functions-json)

### jsquery

в 2014-м году для версии 9.4 Ф. Сигаевым, А. Коротковым и О. Бартуновым было разработано
расширение jsquery. Это расширение определяет язык запросов для извлечения данных из jsonb и индексы для
ускорения этих запросов. Для этого появился новый тип
данных — jsquery

С помощью языка запросов можно, например, искать записи, указывая путь. Нотация с точками отображает иерархию
внутри jsonb:
test=# SELECT *
FROM student_details
WHERE details::jsonb @@
'хобби.гитарист.группа=Постгрессоры'::jsquery;
В случае, когда мы не знаем путь, можно подменить ветви
звездочкой:
test=# SELECT s_id, details
FROM student_details
WHERE details::jsonb @@
'хобби.*.группа=Постгрессоры'::jsquery;
-
### Postgres Professional

Когда вышел стандарт SQL:2016, в который входит и язык
путей SQL/JSON Path, в Postgres Professional был разработана его реализация, добавляющая тип jsonpath и набор
функций для работы с JSON с помощью этого языка. Эти
возможности вошли в PostgreSQL 12.

$.a.b.c — в версии PostgreSQL 11 пришлось бы напи-
сать ’a’->’b’->’c’.
•    $ — текущий контекст элемента. Фактически выражение
с $ задает область JSON, которая подлежит обработке,
в том числе фигурирует в фильтре. Остальная часть в
этом случае для работы недоступна
•    @ — текущий контекст в выражении-фильтре. Перебира-
ются пути, доступные в выражении с $
•    * — метасимвол (wildcard). В выражениях с $ или @ озна-
чает любое значение участка пути, но при этом с учетом
иерархии.
•    ** — как часть выражения с $ или @ может означать лю-
бое значение участка пути без учета иерархии. Удобно
использовать, если не знаем уровень вложенности эле-
ментов.
•    Оператор ? позволяет организовать фильтр, аналогич-
ный WHERE, например $.a.b.c ? (@.x > 10)

Страница 140!!!

С возможностями SQL/JSON Path можно ознакомиться не
только в документации (postgrespro.ru/docs/postgresql/12/
datatype-json#DATATYPE-JSONPATH), но также и в статье
«Что заморозили на feature freeze 2019. Часть I. JSONPath»
(habr.com/ru/company/postgrespro/blog/448612/).

# Интеграция с внешними системами

В PostgreSQL реализована поддержка стандарта ISO/IEC
9075-9 (SQL/MED, Management of External Data) по работе
в SQL с внешними источниками информации через специальный механизм оберток сторонних данных (foreign data
wrapper).

Стр 142

# Шардирование и секционирование

Разница в том, что секции
располагаются на том же сервере, а шарды — на разных

В качестве секций можно
использовать и внешние таблицы, и таким образом секционирование превращается в шардирование

Часть из перечисленных задач уже решена в нашем экспериментальном расширении pg_shardman, доступном на
github.com/postgrespro/pg_shardman.
Для взаимодействия с базами PostgreSQL существует еще
одно расширение, входящее в дистрибутив — dblink. Оно
позволяет явно управлять соединениями (подключаться,
отключаться), выполнять запросы и получить результаты
асинхронно: postgrespro.ru/doc/dblink.html

### Что почитать

[читать сайт-агрегатор](planet.postgresql.org) 
    Удобный способ получить все англоязычные заметки в одном месте — читать сайт-агрегатор .

[Статьи на Хабре](habr.com/hub/postgresql)
    Большое количество статей на русском языке публикуется на сайте habr.com/hub/postgresql, в том числе и нашей
компанией.

[сборник статей](wiki.postgresql.org)
Не забывайте и про wiki.postgresql.org — сборник статей,
поддерживаемый и развиваемый сообществом.

### Версии СУБД

Postgres Pro Standard содержит все функциональные возможности PostgreSQL с дополнительными патчами ядра,
которые скоро будут приняты сообществом, а также расширениями и патчами, разработанными Postgres Professional.
Таким образом, клиенты могут получить доступ к полезной
функциональности и получить выигрыш в производительности, не дожидаясь очередного релиза PostgreSQL.

Postgres Pro Enterprise представляет собой глубоко переработанную версию СУБД, содержащую существенные изменения, повышающие ее надежность, производительность
и применимость для серьезных промышленных задач.
Обе версии Postgres Pro, дополненные необходимыми
средствами защиты информации, прошли сертификацию
ФСТЭК.